{% extends "theme.html" %}
{% block title %}2FA Recording{% endblock %}

{% block content %}

<head>
    <style>
        .recordingcircle {
            height: 250px;
            width: 250px;
            border-radius: 50%;
            background-color: #99ccff;
            animation: scaling1 3s ease-in-out infinite;
        }

        .pendingcircle {
            height: 250px;
            width: 250px;
            border-radius: 50%;
            background-color: #99ccff;
            animation: scaling2 3s ease-in-out infinite;
        }

        .center {
            margin: auto;
            text-align: center;
        }

        @keyframes scaling1 {
            0%, 100% {
                transform: scale(0.2);
                background-color: #99ccff;
            }

            50% {
                transform: scale(1);
                background-color: #ff6666;
            }
        }

        @keyframes scaling2 {
            0%, 100% {
                transform: scale(0.2);
                background-color: #99ccff;
            }

            50% {
                transform: scale(1);
                background-color: #66ff99;
            }
        }
    </style>
</head>

<h4 id='message'>{{message}}</h4>
<div id="notifdiv" class="center" style="font-weight: bold;">NOW RECORDING FOR AUTHENTICATION</div>
<br>
<div id="notificationcircle" class="recordingcircle center"></div>
<br>
<br>
<br>

<form method="post">
    <div class="form-group">
        <label for="TOTP">Alternatively enter the 2FA code generated by the SoundProof app</label>
        <input class="form-control" name="totp_code" id="totp_code" required>
        <input class="btn btn-lg btn-primary" type="submit" id="btn-submit" value="Submit">
    </div>
</form>

<script type="text/javascript" src="{{ url_for('static', filename="bower_components/crypto-js/crypto-js.js") }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename="bower_components/jsrsasign-all-min.js") }}"></script>
<script>
    var notifCircle = document.getElementById("notificationcircle");
    var notifText = document.getElementById("notifdiv");

    var pubKey = "{{ pubic_key }}";
    var email = "{{ email }}";
    var constraints = { audio: true };
    var recordingTime;

    navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
        var mediaRecorder = new MediaRecorder(stream);
        var chunks = [];

        Sync();
        mediaRecorder.start();
        timeout = setTimeout(function () { stopRecording(); }, 3000)

        mediaRecorder.addEventListener('dataavailable', function (event) {
            chunks.push(event.data);
        });
        mediaRecorder.addEventListener('stop', function () {
            var blob = new Blob(chunks, { type: 'audio/wav' });

            var reader = new FileReader();
            reader.onloadend = () => {
                var audioB64 = reader.result;
                var prefix = audioB64.substr(0, 22);
                var encryptable_portion = audioB64.substr(22);

                var key = generateRandom(32);
                var iv = generateRandom(16);
                var parsedkey = CryptoJS.enc.Latin1.parse(key);
                var parsediv = CryptoJS.enc.Latin1.parse(iv);

                pubKeyObj = KEYUTIL.getKey(pubKey);
                var encrypedAESKey = hextob64(KJUR.crypto.Cipher.encrypt(key, pubKeyObj, "RSA"));

                var encryption = CryptoJS.AES.encrypt(encryptable_portion, parsedkey, { iv: parsediv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 })
                var encrypted = encryption.toString();
                var decrypted = CryptoJS.AES.decrypt(encrypted, parsedkey, { iv: parsediv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }).toString(CryptoJS.enc.Utf8);

                var decoded = new Audio(prefix + decrypted);
                decoded.play();

                var recordingData = {}
                recordingData["time"] = recordingTime;
                recordingData["key"] = encrypedAESKey;
                recordingData["iv"] = iv;
                recordingData["b64audio"] = encrypted;
                fetch('/uploadaudio', { 
                    headers: {
                        'email': email
                    },
                    method: 'POST',
                    body: JSON.stringify(recordingData)
                }).then(function (response) {
                    return response.text().then(function (text) {
                        window.location.href = text;
                    });
                });
            }
            reader.readAsDataURL(blob);

            chunks = [];
        });

        function stopRecording() {
            mediaRecorder.stop();
            notifText.innerHTML = "RECORDING FINISHED - WAITING FOR VERIFICATION";
            notifCircle.classList = "pendingcircle center";
        }

        function generateRandom(size) {
            var out = '';
            var set = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (var i = 0; i < size; i++) {
                out += set.charAt(Math.floor(Math.random() * 62));
            }
            return out;
        }
    });

    function Sync() {
        console.log("syncin")
        var timeRequest = new XMLHttpRequest();
        var requestTime = (new Date).getTime();

        timeRequest.open('GET', "{{ url_for('spAPI.servertime') }}");
        timeRequest.onreadystatechange = function () {
            if (timeRequest.readyState != 4) {
                return;
            }
            var responseTime = (new Date).getTime();
            var rtdLatency = (responseTime - requestTime)/2;
            var serverTimeAtRequest = parseFloat(timeRequest.response);

            serverTime = serverTimeAtRequest+rtdLatency;

            console.log("client time request made", requestTime.valueOf());
            console.log("client time recieve response", responseTime.valueOf());
            console.log("latency", rtdLatency.valueOf());
            console.log("server's time when request recieved", serverTimeAtRequest);
            console.log("server time + latency", serverTime);

            recordingTime = serverTime.valueOf();
        };
        timeRequest.send(null);
    }
</script>

{% endblock %}