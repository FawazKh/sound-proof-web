{% extends "theme.html" %}
{% block title %}2FA Recording{% endblock %}

{% block content %}

<head>
    <style>
        .recordingcircle {
            height: 250px;
            width: 250px;
            border-radius: 50%;
            background-color: #99ccff;
            animation: scaling1 3s ease-in-out infinite;
        }

        .pendingcircle {
            height: 250px;
            width: 250px;
            border-radius: 50%;
            background-color: #99ccff;
            animation: scaling2 3s ease-in-out infinite;
        }

        .center {
            margin: auto;
            text-align: center;
        }

        @keyframes scaling1 {
            0%, 100% {
                transform: scale(0.2);
                background-color: #99ccff;
            }

            50% {
                transform: scale(1);
                background-color: #ff6666;
            }
        }

        @keyframes scaling2 {
            0%, 100% {
                transform: scale(0.2);
                background-color: #99ccff;
            }

            50% {
                transform: scale(1);
                background-color: #66ff99;
            }
        }
    </style>
</head>

<h4 id='message'>{{message}}</h4>
<div id="notifdiv" class="center" style="font-weight: bold;">NOW RECORDING FOR AUTHENTICATION</div>
<br>
<div id="notificationcircle" class="recordingcircle center"></div>
<br>
<br>
<br>

<form method="post">
    <div class="form-group">
        <label for="TOTP">Alternatively enter the 2FA code generated by the SoundProof app</label>
        <input class="form-control" name="totp_code" id="totp_code" required>
        <input class="btn btn-lg btn-primary" type="submit" id="btn-submit" value="Submit">
    </div>
</form>

<script type="text/javascript" src="{{ url_for('static', filename="bower_components/crypto-js/crypto-js.js") }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename="bower_components/jsrsasign-all-min.js") }}"></script>
<script type="module">
    import { MediaRecorder, register } from 'https://jspm.dev/extendable-media-recorder';
    import { connect } from 'https://jspm.dev/extendable-media-recorder-wav-encoder';

    await register(await connect());


    var notifCircle = document.getElementById("notificationcircle");
    var notifText = document.getElementById("notifdiv");

    var pubKey = "{{ pubic_key }}";
    var email = "{{ email }}";
    var recordingTime;

    const constraints = {
        audio: {
            channelCount: 1,
            sampleSize: 16
        }
    }
    const chunks = [];
    const stream = await navigator.mediaDevices.getUserMedia({ audio: constraints });
    let track = stream.getAudioTracks()[0];
    const mediaRecoder = new MediaRecorder(stream, { mimeType: 'audio/wav' });

    mediaRecoder.addEventListener('dataavailable', ({ data }) => {
        chunks.push(data);
    });
    mediaRecoder.addEventListener('stop', ({ data }) => {
        const blob = new Blob(chunks, { type: mediaRecoder.mimeType });

        var reader = new FileReader();
        reader.onloadend = () => {
            var audioB64 = reader.result;
            var prefix = audioB64.substr(0, 22);
            var encryptable_portion = audioB64.substr(22);

            var key = generateRandom(32);
            var iv = generateRandom(16);
            var parsedkey = CryptoJS.enc.Latin1.parse(key);
            var parsediv = CryptoJS.enc.Latin1.parse(iv);

            pubKeyObj = KEYUTIL.getKey(pubKey);
            var encrypedAESKey = hextob64(KJUR.crypto.Cipher.encrypt(key, pubKeyObj, "RSA"));

            var encryption = CryptoJS.AES.encrypt(encryptable_portion, parsedkey, { iv: parsediv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 })
            var encrypted = encryption.toString();

            var recordingData = {}
            recordingData["time"] = recordingTime;
            recordingData["key"] = encrypedAESKey;
            recordingData["iv"] = iv;
            recordingData["prefix"] = prefix;
            recordingData["b64audio"] = encrypted;
            fetch('/uploadaudio', {
                headers: {
                    'email': email
                },
                method: 'POST',
                body: JSON.stringify(recordingData)
            }).then(function (response) {
                return response.text().then(function (text) {
                    window.location.href = text;
                });
            });
        }
        reader.readAsDataURL(blob);
    });

    function Sync() {
        var timeRequest = new XMLHttpRequest();
        var requestTime = (new Date).getTime();

        timeRequest.open('GET', "{{ url_for('spAPI.servertime') }}");
        timeRequest.onreadystatechange = function () {
            if (timeRequest.readyState != 4) {
                return;
            }
            var responseTime = (new Date).getTime();
            var rtdLatency = (responseTime - requestTime) / 2;
            var serverTimeAtRequest = parseFloat(timeRequest.response);

            serverTime = serverTimeAtRequest + rtdLatency;

            recordingTime = serverTime.valueOf();
        };
        timeRequest.send(null);
    }

    function generateRandom(size) {
        var out = '';
        var set = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (var i = 0; i < size; i++) {
            out += set.charAt(Math.floor(Math.random() * 62));
        }
        return out;
    }

    Sync();
    mediaRecoder.start();
    let timeout = setTimeout(function () {
        mediaRecoder.stop();
        notifText.innerHTML = "RECORDING FINISHED - WAITING FOR VERIFICATION";
        notifCircle.classList = "pendingcircle center";
    }, 3000);
</script>

{% endblock %}